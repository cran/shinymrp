<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Spatial priors implementation in shinymrp</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Spatial priors implementation in
shinymrp</h1>



<p>Conditional Autoregressive (CAR) models are commonly used to
represent local dependency between random variables. We provide two
popular members of this family of models as priors for our hierarchical
models:</p>
<ul>
<li>Intrinsic CAR (ICAR): an intrinsic (improper) Gaussian Markov random
field that smooths by penalizing neighbor differences</li>
<li>BYM2: a reparameterization of the BYM (Besag-York-Mollié) model that
combines a structured ICAR component with a spatially independent
component and incorporates scaling to standardize interpretation across
graphs.</li>
</ul>
<div id="areal-data-neighborhood-graph" class="section level2">
<h2>Areal data &amp; neighborhood graph</h2>
<p>These models specifically apply to <em>areal data</em>, which consist
of a single aggregated measure for each areal unit. In spatial modeling,
the primary interest lies in the <strong>relationships between
units</strong> rather than in the units themselves. Common approaches to
define these relationships include <strong>rook</strong> and
<strong>queen contiguity</strong>, which identify two areal units as
neighbors if they share a border. We use the <code>spdep</code> package
to construct neighborhood graphs from areal units. For ZIP codes,
<strong>ZCTAs</strong> (ZIP Code Tabulation Areas) are used as proxies
to infer the adjacency structure. A common mathematical representation
of this structure is the <strong>adjacency matrix</strong>, denoted
<span class="math inline">\(\mathbf{W}\)</span>. Because the edges are
undirected, <span class="math inline">\(\mathbf{W}\)</span> is an <span class="math inline">\(N \times N\)</span> symmetric matrix for a set of
<span class="math inline">\(N\)</span> areal units. This representation
enables mathematical operations that yield valuable insights into the
neighborhood graph, as will be illustrated in later sections.</p>
<p>The <strong>connectivity</strong> of the graph can affect the choice
of spatial model. For instance, the ICAR prior requires a connected
graph. A <strong>connected</strong> graph contains a single
<strong>component</strong>, meaning that each node can be reached from
any other node. Conversely, a graph with multiple components is
<strong>disconnected</strong>, as nodes in one component cannot reach
those in another. A component of size one is referred to as an
<strong>island</strong> (or <strong>isolate</strong>). Since the
structured component of a spatial model relies on neighborhood edges for
smoothing, these isolates require special handling.</p>
</div>
<div id="intrinsic-conditional-auto-regressive-icar-models" class="section level2">
<h2>Intrinsic Conditional Auto-Regressive (ICAR) models</h2>
<p>At the heart of an <strong>ICAR model</strong> is a multivariate
normal random variable <span class="math inline">\(\boldsymbol{\phi}\)</span>, where each element
<span class="math inline">\(\phi_i\)</span> is conditionally distributed
based on a weighted sum of its neighboring values. The locality of this
specification is analogous to the definition of a <strong>Markov random
field</strong>. Under the assumption of complete spatial correlation,
the ICAR model defines the joint distribution of <span class="math inline">\(\boldsymbol{\phi}\)</span> as:</p>
<p><span class="math display">\[ \boldsymbol{\phi} \sim
\mathcal{N}(\mathbf{0}, \mathbf{L}^{-1}) \]</span></p>
<p>where <span class="math inline">\(\mathbf{L}\)</span> is the
<strong>graph Laplacian matrix</strong>. Through linear algebra, the
log-probability density can be expressed in terms of the pairwise
differences between neighboring values of <span class="math inline">\(\boldsymbol{\phi}\)</span>: <span class="math display">\[ \log p(\boldsymbol{\phi}) \propto -\frac{1}{2}
\sum_{i \sim j} (\phi_i - \phi_j)^2 \]</span> This formulation
explicitly shows how the neighborhood structure is incorporated into the
joint probability. It also reveals the <strong>non-identifiability
problem</strong> of the ICAR model, which arises because adding a
constant to all elements of <span class="math inline">\(\boldsymbol{\phi}\)</span> does not change the
differences. To resolve this, a <strong>sum-to-zero constraint</strong>
is imposed: <span class="math display">\[ \sum_{i=1}^{N} \phi_i = 0
\]</span> This constraint also prevents <span class="math inline">\(\boldsymbol{\phi}\)</span> from confounding the
model intercept.</p>
<div id="stan-implementation" class="section level3">
<h3>Stan implementation</h3>
<p>The implementation in Stan is straightforward with the pairwise
difference fomulation.</p>
<p>Function for computating the log probability density</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="kw">functions</span> { </span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="dt">real</span> icar_normal_lpdf(<span class="dt">vector</span> phi, <span class="dt">array</span>[] <span class="dt">int</span> node1, <span class="dt">array</span>[] <span class="dt">int</span> node2) {</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>    <span class="cf">return</span> -<span class="fl">0.5</span> * dot_self(phi[node1] - phi[node2]);</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  }</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Pass neighborhood information using edges defined by node indices</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; N;  <span class="co">// number of areal regions</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; N_edges;  <span class="co">// number of neighbor pairs</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  <span class="dt">array</span>[N_edges] <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">1</span>, <span class="kw">upper</span> = N&gt; node1;</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  <span class="dt">array</span>[N_edges] <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">1</span>, <span class="kw">upper</span> = N&gt; node2;</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Use Stan’s built-in sum_to_zero_vector to constrain phi</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  sum_to_zero_vector[N] phi; <span class="co">// structured spatial random effects</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Add to joint probability density using Stan’s distribution
statement</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  phi ~ icar_normal(node1, node2);</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  ...</span></code></pre></div>
</div>
</div>
<div id="bym2-model" class="section level2">
<h2>BYM2 model</h2>
<p>The assumption of complete spatial correlation in ICAR models limits
their applicability to most real datasets. The BYM (Besag–York–Mollié)
model addresses this by adding an unstructured spatial random effect to
account for independent region-specific noise. However, having both
structured and unstructured components introduces confounding. The BYM2
model (Riebler et al., 2016) reparameterizes BYM to improve
interpretability of parameters and hyperpriors without sacrificing
performance. When a spatial random effect is assigned a BYM2 prior, it
is modeled as a convex-like mixture of a standardized unstructured term
and a scaled ICAR term:</p>
<p><span class="math display">\[ b_i \;=\; \Big(\sqrt{\rho/s}\;\phi_i
\;+\; \sqrt{1-\rho}\;\theta_i\Big) \sigma, \qquad i=1,\dots,N,
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\phi_i\)</span> is the ICAR
component</li>
<li><span class="math inline">\(\theta_i\)</span> is the unstructured
spatial effect</li>
<li><span class="math inline">\(s\)</span> is the scaling factor
computed from the neighborhood graph such that <span class="math inline">\(\operatorname{Var}(\phi_i) = 1\)</span></li>
<li><span class="math inline">\(\rho \in [0,1]\)</span> controls the
mixing between unstructured and structured components</li>
<li><span class="math inline">\(\sigma &gt; 0\)</span> is the overall
standard deviation.</li>
</ul>
<div id="stan-implementation-for-connected-graph" class="section level3">
<h3>Stan implementation for connected graph</h3>
<p>We can use the implementation of the ICAR component in the previous
section.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="kw">functions</span> { </span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="dt">real</span> icar_normal_lpdf(<span class="dt">vector</span> phi, <span class="dt">array</span>[] <span class="dt">int</span> node1, <span class="dt">array</span>[] <span class="dt">int</span> node2) {</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="cf">return</span> -<span class="fl">0.5</span> * dot_self(phi[node1] - phi[node2]);</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  }</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Pass the scaling factor computed from the adjacency matrix in
addition to the edgelist</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; N;  <span class="co">// number of areal regions</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; N_edges;  <span class="co">// number of neighbor pairs</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="dt">array</span>[N_edges] <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">1</span>, <span class="kw">upper</span> = N&gt; node1;</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="dt">array</span>[N_edges] <span class="dt">int</span>&lt;<span class="kw">lower</span> = <span class="dv">1</span>, <span class="kw">upper</span> = N&gt; node2;</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; scale_factor;</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Use Stan’s built-in sum_to_zero_vector to constrain phi</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma; <span class="co">// overall standard deviation for spatial effect</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; rho; <span class="co">// mixing parameter </span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="dt">vector</span>[N] theta; <span class="co">// unstructured spatial random effect</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  sum_to_zero_vector[N] phi; <span class="co">// structured spatial random effect</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Compute combined spatial effect</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>transformed_parameters {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  <span class="dt">vector</span>[N] b = sqrt(rho ./ scale_factor) * phi + sqrt(<span class="dv">1</span> - rho) * theta</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Assigning priors</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  theta ~ std_normal();</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  phi ~ icar_normal(node1, node2);</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  rho ~ beta(<span class="fl">0.5</span>, <span class="fl">0.5</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  sigma ~ std_normal();</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  ...</span></code></pre></div>
</div>
<div id="bym2-reparameterization-for-disconnected-graph" class="section level3">
<h3>BYM2 reparameterization for disconnected graph</h3>
<p>According to Freni-Sterrantino et al. (2018), the BYM2 model can be
extended to graphs with multiple components as follows:</p>
<ul>
<li>Component nodes are given the BYM2 prior</li>
<li>Singleton nodes (islands) are given a standard Normal prior</li>
<li>Compute per-connected component scaling factor</li>
<li>Impose a sum-to-zero constraint on each connected component</li>
</ul>
<p>To make this extension easier, we reparameterize the structured ICAR
field on a basis that (i) lies in each component’s sum-to-zero subspace
and (ii) is BYM2-standardized. Isolates get no structured variance and
only receive the spatially independent part.</p>
<p>Consider a single connected neighborhood graph with <span class="math inline">\(N\ge2\)</span> areas. Let <span class="math inline">\(A\)</span> be the symmetric adjacency, <span class="math inline">\(D=\mathrm{diag}(d_i)\)</span> the degree matrix,
and <span class="math inline">\(L=D-A\)</span> the graph Laplacian.
Because the graph is connected, <span class="math inline">\(L\mathbf
1=0\)</span> and <span class="math inline">\(\mathrm{null}(L)=\mathrm{span}\{\mathbf
1\}\)</span>. The intrinsic CAR prior has log-density <span class="math inline">\(-\tfrac12\,\phi^\top L\,\phi\)</span>; it is
improper on <span class="math inline">\(\mathbb R^N\)</span> but becomes
proper on the sum-to-zero subspace <span class="math display">\[
\mathcal H=\{\phi\in\mathbb R^N:\mathbf 1^\top \phi=0\}.
\]</span></p>
<p>Since <span class="math inline">\(L\)</span> is symmetric positive
semidefinite, diagonalize <span class="math inline">\(L=U\Lambda
U^\top\)</span> where the eigenvalues satisfy <span class="math inline">\(0=\lambda_1&lt;\lambda_2\le\cdots\le\lambda_N\)</span>,
with <span class="math inline">\(u_1\propto \mathbf 1\)</span>. Write
<span class="math inline">\(U_+=[u_2,\ldots,u_N]\in\mathbb
R^{N\times(N-1)}\)</span> and <span class="math inline">\(\Lambda_+=\mathrm{diag}(\lambda_2,\ldots,\lambda_N)\)</span>.
The Moore–Penrose pseudoinverse is <span class="math display">\[
L^{+}=U_+\Lambda_+^{-1}U_+^\top,
\]</span> which equals the covariance of the ICAR prior restricted to
<span class="math inline">\(\mathcal H\)</span>.</p>
<p>Define the basis <span class="math display">\[
R \;=\; U_+\,\Lambda_+^{-1/2}\in\mathbb R^{N\times(N-1)},\qquad \eta
\sim \mathcal N(0,I_{N-1}),\qquad \phi \;=\; R\,\eta.
\]</span> This reparameterization is equivalent to the constrained ICAR
in the following sense. First, the support matches because each column
of <span class="math inline">\(R\)</span> is orthogonal to <span class="math inline">\(\mathbf 1\)</span>, hence <span class="math inline">\(\mathbf 1^\top\phi=\mathbf 1^\top R\eta=0\)</span>
for all <span class="math inline">\(\eta\)</span>, i.e., <span class="math inline">\(\phi\in\mathcal H\)</span>. Second, the mean
matches since <span class="math inline">\(\mathbb E[\phi]=R\,\mathbb
E[\eta]=0\)</span>. Third, the covariance matches because <span class="math display">\[
\mathrm{Var}(\phi) \;=\; R\,\mathrm{Var}(\eta)\,R^\top \;=\; R R^\top
\;=\; U_+\Lambda_+^{-1}U_+^\top \;=\; L^{+}.
\]</span> Linear images of a multivariate normal are normal; therefore
<span class="math inline">\(\phi\stackrel{d}{=}\mathcal
N(0,L^{+})\)</span> on <span class="math inline">\(\mathcal H\)</span>.
Right-orthogonal rotations of the scores, <span class="math inline">\(R\mapsto RQ\)</span> with <span class="math inline">\(Q\)</span> orthogonal, leave <span class="math inline">\(R R^\top\)</span> unchanged; the parameterization
is not unique but the induced law for <span class="math inline">\(\phi\)</span> is.</p>
<p>BYM2 standardization rescales the structured field so that the
geometric mean of its marginal variances equals one. Let <span class="math inline">\(v_i=(L^{+})_{ii}\)</span> and define <span class="math display">\[
s \;=\; \exp\Big(\tfrac{1}{N}\sum_{i=1}^N \log v_i\Big),\qquad
R_{\text{BYM2}} \;=\; \frac{1}{\sqrt{s}}\,R,\qquad \tilde\phi \;=\;
R_{\text{BYM2}}\,\eta.
\]</span> Then <span class="math inline">\(\mathrm{GM}\big(\operatorname{diag}\mathrm{Var}(\tilde\phi)\big)=1\)</span>,
while <span class="math inline">\(\mathbf 1^\top \tilde\phi=0\)</span>
still holds because the subspace is unchanged.</p>
</div>
<div id="stan-implementation-for-all-graphs" class="section level3">
<h3>Stan implementation for all graphs</h3>
<p>The reparameterization allows more cleaner implementation as the
reduced-rank ICAR basis is already BYM2-standardized and enforces the
sum-to-zero constraint by construction. The sum_to_zero vector is not
longer needed which can improve sampling.</p>
<p>Pass the scaled reduced-rank ICAR basis</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;  <span class="co">// number of areal regions</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_pos;</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="dt">matrix</span>[N_zip, N_pos] R; <span class="co">// already scaled so that geometric mean of</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>                          <span class="co">// marginal variance is 1</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  ...</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma; <span class="co">// overall standard deviation for spatial effect</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; rho; <span class="co">// mixing parameter </span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="dt">vector</span>[N] theta; <span class="co">// unstructured spatial random effect</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="dt">vector</span>[N] eta; <span class="co">// structured reduced-rank scores</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Compute the scaled ICAR component and combined spatial effect</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>transformed_parameters {</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="dt">vector</span>[N] phi = R * eta;</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="dt">vector</span>[N] b = sqrt(rho) * phi + sqrt(<span class="dv">1</span> - rho) * theta</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>  ...</span></code></pre></div>
<p>Assigning priors</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  eta ~ std_normal();</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>  theta ~ std_normal();</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  rho ~ beta(<span class="fl">0.5</span>, <span class="fl">0.5</span>)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  sigma ~ std_normal();</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  ...</span></code></pre></div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
